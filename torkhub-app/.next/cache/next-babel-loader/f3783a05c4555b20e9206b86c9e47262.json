{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime-corejs2/regenerator\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _mitt = _interopRequireDefault(require(\"../next-server/lib/mitt\"));\n\nfunction hasRel(rel, link) {\n  try {\n    link = document.createElement('link');\n    return link.relList.supports(rel);\n  } catch (_unused) {}\n}\n\nvar relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload\n// macOS and iOS (Safari does not support prefetch)\n'preload' : // https://caniuse.com/#feat=link-rel-prefetch\n// IE 11, Edge 12+, nearly all evergreen\n'prefetch';\nvar hasNoModule = ('noModule' in document.createElement('script'));\n\nfunction appendLink(href, rel, as) {\n  return new _promise.default((res, rej, link) => {\n    link = document.createElement('link');\n    link.crossOrigin = process.crossOrigin;\n    link.href = href;\n    link.rel = rel;\n    if (as) link.as = as;\n    link.onload = res;\n    link.onerror = rej;\n    document.head.appendChild(link);\n  });\n}\n\nclass PageLoader {\n  constructor(buildId, assetPrefix) {\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.prefetched = {};\n    this.pageRegisterEvents = (0, _mitt.default)();\n    this.loadingRoutes = {};\n\n    if (process.env.__NEXT_GRANULAR_CHUNKS) {\n      this.promisedBuildManifest = new _promise.default(resolve => {\n        if (window.__BUILD_MANIFEST) {\n          resolve(window.__BUILD_MANIFEST);\n        } else {\n          window.__BUILD_MANIFEST_CB = () => {\n            resolve(window.__BUILD_MANIFEST);\n          };\n        }\n      });\n    }\n  } // Returns a promise for the dependencies for a particular route\n\n\n  getDependencies(route) {\n    return this.promisedBuildManifest.then(man => man[route] && man[route].map(url => \"/_next/\" + encodeURI(url)) || []);\n  }\n\n  normalizeRoute(route) {\n    if (route[0] !== '/') {\n      throw new Error(\"Route name should start with a \\\"/\\\", got \\\"\" + route + \"\\\"\");\n    }\n\n    route = route.replace(/\\/index$/, '/');\n    if (route === '/') return route;\n    return route.replace(/\\/$/, '');\n  }\n\n  loadPage(route) {\n    return this.loadPageScript(route).then(v => v.page);\n  }\n\n  loadPageScript(route) {\n    route = this.normalizeRoute(route);\n    return new _promise.default((resolve, reject) => {\n      var fire = _ref => {\n        var error = _ref.error,\n            page = _ref.page,\n            mod = _ref.mod;\n        this.pageRegisterEvents.off(route, fire);\n        delete this.loadingRoutes[route];\n\n        if (error) {\n          reject(error);\n        } else {\n          resolve({\n            page,\n            mod\n          });\n        }\n      }; // If there's a cached version of the page, let's use it.\n\n\n      var cachedPage = this.pageCache[route];\n\n      if (cachedPage) {\n        var error = cachedPage.error,\n            page = cachedPage.page,\n            mod = cachedPage.mod;\n        error ? reject(error) : resolve({\n          page,\n          mod\n        });\n        return;\n      } // Register a listener to get the page\n\n\n      this.pageRegisterEvents.on(route, fire); // If the page is loading via SSR, we need to wait for it\n      // rather downloading it again.\n\n      if (document.querySelector(\"script[data-next-page=\\\"\" + route + \"\\\"]\")) {\n        return;\n      }\n\n      if (!this.loadingRoutes[route]) {\n        this.loadingRoutes[route] = true;\n\n        if (process.env.__NEXT_GRANULAR_CHUNKS) {\n          this.getDependencies(route).then(deps => {\n            deps.forEach(d => {\n              if (/\\.js$/.test(d) && !document.querySelector(\"script[src^=\\\"\" + d + \"\\\"]\")) {\n                this.loadScript(d, route, false);\n              }\n\n              if (/\\.css$/.test(d) && !document.querySelector(\"link[rel=stylesheet][href^=\\\"\" + d + \"\\\"]\")) {\n                appendLink(d, 'stylesheet').catch(() => {// FIXME: handle failure\n                  // Right now, this is needed to prevent an unhandled rejection.\n                });\n              }\n            });\n            this.loadRoute(route);\n          });\n        } else {\n          this.loadRoute(route);\n        }\n      }\n    });\n  }\n\n  loadRoute(route) {\n    var _this = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var scriptRoute, url;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            route = _this.normalizeRoute(route);\n            scriptRoute = route === '/' ? '/index.js' : route + \".js\";\n            url = _this.assetPrefix + \"/_next/static/\" + encodeURIComponent(_this.buildId) + \"/pages\" + encodeURI(scriptRoute);\n\n            _this.loadScript(url, route, true);\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n\n  loadScript(url, route, isPage) {\n    var script = document.createElement('script');\n\n    if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n      script.type = 'module'; // Only page bundle scripts need to have .module added to url,\n      // dependencies already have it added during build manifest creation\n\n      if (isPage) url = url.replace(/\\.js$/, '.module.js');\n    }\n\n    script.crossOrigin = process.crossOrigin;\n    script.src = url;\n\n    script.onerror = () => {\n      var error = new Error(\"Error loading script \" + url);\n      error.code = 'PAGE_LOAD_ERROR';\n      this.pageRegisterEvents.emit(route, {\n        error\n      });\n    };\n\n    document.body.appendChild(script);\n  } // This method if called by the route code.\n\n\n  registerPage(route, regFn) {\n    var register = () => {\n      try {\n        var mod = regFn();\n        var pageData = {\n          page: mod.default || mod,\n          mod\n        };\n        this.pageCache[route] = pageData;\n        this.pageRegisterEvents.emit(route, pageData);\n      } catch (error) {\n        this.pageCache[route] = {\n          error\n        };\n        this.pageRegisterEvents.emit(route, {\n          error\n        });\n      }\n    };\n\n    if (false) {\n      // Wait for webpack to become idle if it's not.\n      // More info: https://github.com/zeit/next.js/pull/1511\n      if (module.hot && module.hot.status() !== 'idle') {\n        console.log(\"Waiting for webpack to become \\\"idle\\\" to initialize the page: \\\"\" + route + \"\\\"\");\n\n        var check = status => {\n          if (status === 'idle') {\n            module.hot.removeStatusHandler(check);\n            register();\n          }\n        };\n\n        module.hot.status(check);\n        return;\n      }\n    }\n\n    register();\n  }\n\n  prefetch(route, isDependency) {\n    var _this2 = this;\n\n    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var cn, url, scriptRoute;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(cn = navigator.connection)) {\n              _context2.next = 3;\n              break;\n            }\n\n            if (!(cn.saveData || /2g/.test(cn.effectiveType))) {\n              _context2.next = 3;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 3:\n            url = _this2.assetPrefix;\n\n            if (isDependency) {\n              url += route;\n            } else {\n              route = _this2.normalizeRoute(route);\n              _this2.prefetched[route] = true;\n              scriptRoute = (route === '/' ? '/index' : route) + \".js\";\n\n              if (process.env.__NEXT_MODERN_BUILD && hasNoModule) {\n                scriptRoute = scriptRoute.replace(/\\.js$/, '.module.js');\n              }\n\n              url += \"/_next/static/\" + encodeURIComponent(_this2.buildId) + \"/pages\" + encodeURI(scriptRoute);\n            }\n\n            if (!document.querySelector(\"link[rel=\\\"\" + relPrefetch + \"\\\"][href^=\\\"\" + url + \"\\\"], script[data-next-page=\\\"\" + route + \"\\\"]\")) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 7:\n            return _context2.abrupt(\"return\", _promise.default.all([appendLink(url, relPrefetch, url.match(/\\.css$/) ? 'style' : 'script'), process.env.__NEXT_GRANULAR_CHUNKS && !isDependency && _this2.getDependencies(route).then(urls => _promise.default.all(urls.map(url => _this2.prefetch(url, true))))]).then( // do not return any data\n            () => {}, // swallow prefetch errors\n            () => {}));\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n\n}\n\nexports.default = PageLoader;","map":null,"metadata":{},"sourceType":"script"}