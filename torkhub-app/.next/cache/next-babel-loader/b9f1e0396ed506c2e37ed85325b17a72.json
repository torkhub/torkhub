{"ast":null,"code":"import _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _Date$now from \"@babel/runtime-corejs2/core-js/date/now\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport deepEqual from 'fast-deep-equal';\nimport { useCallback, useContext, useEffect, useLayoutEffect, useState, useRef, useMemo } from 'react';\nimport defaultConfig, { cacheGet, cacheSet, CACHE_REVALIDATORS, CONCURRENT_PROMISES, CONCURRENT_PROMISES_TS, FOCUS_REVALIDATORS, MUTATION_TS } from './config';\nimport hash from './libs/hash';\nimport isDocumentVisible from './libs/is-document-visible';\nimport isOnline from './libs/is-online';\nimport throttle from './libs/throttle';\nimport SWRConfigContext from './swr-config-context';\nconst IS_SERVER = false; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect; // TODO: introduce namepsace for the cache\n\nconst getErrorKey = key => key ? 'err@' + key : '';\n\nconst getKeyArgs = key => {\n  let args = null;\n\n  if (typeof key === 'function') {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n\n  if (_Array$isArray(key)) {\n    // args array\n    args = key;\n    key = hash(key);\n  } else {\n    // convert null to ''\n    key = String(key || '');\n  }\n\n  return [key, args];\n};\n\nconst trigger = (_key, shouldRevalidate = true) => {\n  const _getKeyArgs = getKeyArgs(_key),\n        _getKeyArgs2 = _slicedToArray(_getKeyArgs, 1),\n        key = _getKeyArgs2[0];\n\n  if (!key) return;\n  const updaters = CACHE_REVALIDATORS[key];\n\n  if (key && updaters) {\n    const currentData = cacheGet(key);\n    const currentError = cacheGet(getErrorKey(key));\n\n    for (let i = 0; i < updaters.length; ++i) {\n      updaters[i](shouldRevalidate, currentData, currentError, true);\n    }\n  }\n};\n\nconst broadcastState = (key, data, error) => {\n  const updaters = CACHE_REVALIDATORS[key];\n\n  if (key && updaters) {\n    for (let i = 0; i < updaters.length; ++i) {\n      updaters[i](false, data, error);\n    }\n  }\n};\n\nconst mutate = (_key, _data, shouldRevalidate) => {\n  var _getKeyArgs3, _getKeyArgs4, key, data, error, updaters, i;\n\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        _getKeyArgs3 = getKeyArgs(_key), _getKeyArgs4 = _slicedToArray(_getKeyArgs3, 1), key = _getKeyArgs4[0];\n\n        if (key) {\n          _context.next = 3;\n          break;\n        }\n\n        return _context.abrupt(\"return\");\n\n      case 3:\n        // update timestamp\n        MUTATION_TS[key] = _Date$now() - 1;\n\n        if (!(_data && typeof _data.then === 'function')) {\n          _context.next = 16;\n          break;\n        }\n\n        _context.prev = 5;\n        _context.next = 8;\n        return _regeneratorRuntime.awrap(_data);\n\n      case 8:\n        data = _context.sent;\n        _context.next = 14;\n        break;\n\n      case 11:\n        _context.prev = 11;\n        _context.t0 = _context[\"catch\"](5);\n        error = _context.t0;\n\n      case 14:\n        _context.next = 18;\n        break;\n\n      case 16:\n        data = _data;\n\n        if (typeof shouldRevalidate === 'undefined') {\n          // if it's a sync mutation, we trigger the revalidation by default\n          // because in most cases it's a local mutation\n          shouldRevalidate = true;\n        }\n\n      case 18:\n        if (typeof data !== 'undefined') {\n          // update cached data\n          cacheSet(key, data);\n        } // update existing SWR Hooks' state\n\n\n        updaters = CACHE_REVALIDATORS[key];\n\n        if (updaters) {\n          for (i = 0; i < updaters.length; ++i) {\n            updaters[i](!!shouldRevalidate, data, error, true);\n          }\n        }\n\n      case 21:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, [[5, 11]], _Promise);\n};\n\nfunction useSWR(...args) {\n  let _key,\n      fn,\n      config = {};\n\n  if (args.length >= 1) {\n    _key = args[0];\n  }\n\n  if (args.length > 2) {\n    fn = args[1];\n    config = args[2];\n  } else {\n    if (typeof args[1] === 'function') {\n      fn = args[1];\n    } else if (typeof args[1] === 'object') {\n      config = args[1];\n    }\n  } // we assume `key` as the identifier of the request\n  // `key` can change but `fn` shouldn't\n  // (because `revalidate` only depends on `key`)\n\n\n  const _getKeyArgs5 = getKeyArgs(_key),\n        _getKeyArgs6 = _slicedToArray(_getKeyArgs5, 2),\n        key = _getKeyArgs6[0],\n        fnArgs = _getKeyArgs6[1]; // `keyErr` is the cache key for error objects\n\n\n  const keyErr = getErrorKey(key);\n  config = _Object$assign({}, defaultConfig, useContext(SWRConfigContext), config);\n\n  if (typeof fn === 'undefined') {\n    // use a global fetcher\n    fn = config.fetcher;\n  }\n\n  const initialData = cacheGet(key) || config.initialData;\n  const initialError = cacheGet(keyErr); // if a state is accessed (data, error or isValidating),\n  // we add the state to dependencies so if the state is\n  // updated in the future, we can trigger a rerender\n\n  const stateDependencies = useRef({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  const stateRef = useRef({\n    data: initialData,\n    error: initialError,\n    isValidating: false\n  });\n  const rerender = useState(null)[1];\n  let dispatch = useCallback(payload => {\n    let shouldUpdateState = false;\n\n    for (let k in payload) {\n      stateRef.current[k] = payload[k];\n\n      if (stateDependencies.current[k]) {\n        shouldUpdateState = true;\n      }\n    }\n\n    if (shouldUpdateState || config.suspense) {\n      rerender({});\n    }\n  }, []); // error ref inside revalidate (is last request errored?)\n\n  const unmountedRef = useRef(false);\n  const keyRef = useRef(key); // start a revalidation\n\n  const revalidate = useCallback((revalidateOpts = {}) => {\n    var loading, shouldDeduping, newData, startAt, newState, retryCount;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(!key || !fn)) {\n            _context2.next = 2;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", false);\n\n        case 2:\n          if (!unmountedRef.current) {\n            _context2.next = 4;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", false);\n\n        case 4:\n          revalidateOpts = _Object$assign({\n            dedupe: false\n          }, revalidateOpts);\n          loading = true;\n          shouldDeduping = typeof CONCURRENT_PROMISES[key] !== 'undefined' && revalidateOpts.dedupe; // start fetching\n\n          _context2.prev = 7;\n          dispatch({\n            isValidating: true\n          });\n\n          if (!shouldDeduping) {\n            _context2.next = 16;\n            break;\n          }\n\n          // there's already an ongoing request,\n          // this one needs to be deduplicated.\n          startAt = CONCURRENT_PROMISES_TS[key];\n          _context2.next = 13;\n          return _regeneratorRuntime.awrap(CONCURRENT_PROMISES[key]);\n\n        case 13:\n          newData = _context2.sent;\n          _context2.next = 25;\n          break;\n\n        case 16:\n          // if not deduping the request (hard revalidate) but\n          // there're other ongoing request(s) at the same time,\n          // we need to ignore the other result(s) to avoid\n          // possible race conditions:\n          // req1------------------>res1\n          //      req2-------->res2\n          // in that case, the second response should not be overridden\n          // by the first one.\n          if (CONCURRENT_PROMISES[key]) {\n            // we can mark it as a mutation to ignore\n            // all requests which are fired before this one\n            MUTATION_TS[key] = _Date$now() - 1;\n          } // if no cache being rendered currently (it shows a blank page),\n          // we trigger the loading slow event.\n\n\n          if (config.loadingTimeout && !cacheGet(key)) {\n            setTimeout(() => {\n              if (loading) config.onLoadingSlow(key, config);\n            }, config.loadingTimeout);\n          }\n\n          if (fnArgs !== null) {\n            CONCURRENT_PROMISES[key] = fn(...fnArgs);\n          } else {\n            CONCURRENT_PROMISES[key] = fn(key);\n          }\n\n          CONCURRENT_PROMISES_TS[key] = startAt = _Date$now();\n          setTimeout(() => {\n            delete CONCURRENT_PROMISES[key];\n            delete CONCURRENT_PROMISES_TS[key];\n          }, config.dedupingInterval);\n          _context2.next = 23;\n          return _regeneratorRuntime.awrap(CONCURRENT_PROMISES[key]);\n\n        case 23:\n          newData = _context2.sent;\n          // trigger the success event,\n          // only do this for the original request.\n          config.onSuccess(newData, key, config);\n\n        case 25:\n          if (!(MUTATION_TS[key] && startAt <= MUTATION_TS[key])) {\n            _context2.next = 28;\n            break;\n          }\n\n          dispatch({\n            isValidating: false\n          });\n          return _context2.abrupt(\"return\", false);\n\n        case 28:\n          cacheSet(key, newData);\n          cacheSet(keyErr, undefined);\n          keyRef.current = key; // new state for the reducer\n\n          newState = {\n            isValidating: false\n          };\n\n          if (typeof stateRef.current.error !== 'undefined') {\n            // we don't have an error\n            newState.error = undefined;\n          }\n\n          if (deepEqual(stateRef.current.data, newData)) {// deep compare to avoid extra re-render\n            // do nothing\n          } else {\n            // data changed\n            newState.data = newData;\n          } // merge the new state\n\n\n          dispatch(newState);\n\n          if (!shouldDeduping) {\n            // also update other hooks\n            broadcastState(key, newData, undefined);\n          }\n\n          _context2.next = 47;\n          break;\n\n        case 38:\n          _context2.prev = 38;\n          _context2.t0 = _context2[\"catch\"](7);\n          delete CONCURRENT_PROMISES[key];\n          delete CONCURRENT_PROMISES_TS[key];\n          cacheSet(keyErr, _context2.t0);\n          keyRef.current = key; // get a new error\n          // don't use deep equal for errors\n\n          if (stateRef.current.error !== _context2.t0) {\n            // we keep the stale data\n            dispatch({\n              isValidating: false,\n              error: _context2.t0\n            });\n\n            if (!shouldDeduping) {\n              // also broadcast to update other hooks\n              broadcastState(key, undefined, _context2.t0);\n            }\n          } // events and retry\n\n\n          config.onError(_context2.t0, key, config);\n\n          if (config.shouldRetryOnError) {\n            // when retrying, we always enable deduping\n            retryCount = (revalidateOpts.retryCount || 0) + 1;\n            config.onErrorRetry(_context2.t0, key, config, revalidate, _Object$assign({\n              dedupe: true\n            }, revalidateOpts, {\n              retryCount\n            }));\n          }\n\n        case 47:\n          loading = false;\n          return _context2.abrupt(\"return\", true);\n\n        case 49:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, null, null, [[7, 38]], _Promise);\n  }, [key]); // mounted (client side rendering)\n\n  useIsomorphicLayoutEffect(() => {\n    if (!key) return undefined; // after `key` updates, we need to mark it as mounted\n\n    unmountedRef.current = false; // after the component is mounted (hydrated),\n    // we need to update the data from the cache\n    // and trigger a revalidation\n\n    const currentHookData = stateRef.current.data;\n    const latestKeyedData = cacheGet(key) || config.initialData; // update the state if the key changed or cache updated\n\n    if (keyRef.current !== key || !deepEqual(currentHookData, latestKeyedData)) {\n      dispatch({\n        data: latestKeyedData\n      });\n      keyRef.current = key;\n    } // revalidate with deduping\n\n\n    const softRevalidate = () => revalidate({\n      dedupe: true\n    }); // trigger a revalidation\n\n\n    if (!config.initialData) {\n      if (typeof latestKeyedData !== 'undefined' && !IS_SERVER && window['requestIdleCallback']) {\n        // delay revalidate if there's cache\n        // to not block the rendering\n        window['requestIdleCallback'](softRevalidate);\n      } else {\n        softRevalidate();\n      }\n    } // whenever the window gets focused, revalidate\n\n\n    let onFocus;\n\n    if (config.revalidateOnFocus) {\n      // throttle: avoid being called twice from both listeners\n      // and tabs being switched quickly\n      onFocus = throttle(softRevalidate, config.focusThrottleInterval);\n\n      if (!FOCUS_REVALIDATORS[key]) {\n        FOCUS_REVALIDATORS[key] = [onFocus];\n      } else {\n        FOCUS_REVALIDATORS[key].push(onFocus);\n      }\n    } // register global cache update listener\n\n\n    const onUpdate = (shouldRevalidate = true, updatedData, updatedError, dedupe = true) => {\n      // update hook state\n      const newState = {};\n      let needUpdate = false;\n\n      if (typeof updatedData !== 'undefined' && !deepEqual(stateRef.current.data, updatedData)) {\n        newState.data = updatedData;\n        needUpdate = true;\n      } // always update error\n      // because it can be `undefined`\n\n\n      if (stateRef.current.error !== updatedError) {\n        newState.error = updatedError;\n        needUpdate = true;\n      }\n\n      if (needUpdate) {\n        dispatch(newState);\n      }\n\n      keyRef.current = key;\n\n      if (shouldRevalidate) {\n        if (dedupe) {\n          return softRevalidate();\n        } else {\n          return revalidate();\n        }\n      }\n\n      return false;\n    }; // add updater to listeners\n\n\n    if (!CACHE_REVALIDATORS[key]) {\n      CACHE_REVALIDATORS[key] = [onUpdate];\n    } else {\n      CACHE_REVALIDATORS[key].push(onUpdate);\n    } // set up reconnecting when the browser regains network connection\n\n\n    let reconnect = null;\n\n    if (config.revalidateOnReconnect) {\n      reconnect = addEventListener('online', softRevalidate);\n    }\n\n    return () => {\n      // cleanup\n      dispatch = () => null; // mark it as unmounted\n\n\n      unmountedRef.current = true;\n\n      if (onFocus && FOCUS_REVALIDATORS[key]) {\n        const revalidators = FOCUS_REVALIDATORS[key];\n        const index = revalidators.indexOf(onFocus);\n\n        if (index >= 0) {\n          // 10x faster than splice\n          // https://jsperf.com/array-remove-by-index\n          revalidators[index] = revalidators[revalidators.length - 1];\n          revalidators.pop();\n        }\n      }\n\n      if (CACHE_REVALIDATORS[key]) {\n        const revalidators = CACHE_REVALIDATORS[key];\n        const index = revalidators.indexOf(onUpdate);\n\n        if (index >= 0) {\n          revalidators[index] = revalidators[revalidators.length - 1];\n          revalidators.pop();\n        }\n      }\n\n      if (reconnect !== null) {\n        removeEventListener('online', reconnect);\n      }\n    };\n  }, [key, revalidate]); // set up polling\n\n  useIsomorphicLayoutEffect(() => {\n    let timer = null;\n\n    const tick = () => {\n      return _regeneratorRuntime.async(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(!stateRef.current.error && (config.refreshWhenHidden || isDocumentVisible()) && !config.refreshWhenOffline && isOnline())) {\n              _context3.next = 3;\n              break;\n            }\n\n            _context3.next = 3;\n            return _regeneratorRuntime.awrap(revalidate({\n              dedupe: true\n            }));\n\n          case 3:\n            if (config.refreshInterval) {\n              timer = setTimeout(tick, config.refreshInterval);\n            }\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, null, null, null, _Promise);\n    };\n\n    if (config.refreshInterval) {\n      timer = setTimeout(tick, config.refreshInterval);\n    }\n\n    return () => {\n      if (timer) clearTimeout(timer);\n    };\n  }, [config.refreshInterval, config.refreshWhenHidden, config.refreshWhenOffline, revalidate]); // suspense\n\n  if (config.suspense) {\n    if (IS_SERVER) throw new Error('Suspense on server side is not yet supported!'); // in suspense mode, we can't return empty state\n    // (it should be suspended)\n    // try to get data and error from cache\n\n    let latestData = cacheGet(key);\n    let latestError = cacheGet(keyErr);\n\n    if (typeof latestData === 'undefined' && typeof latestError === 'undefined') {\n      // need to start the request if it hasn't\n      if (!CONCURRENT_PROMISES[key]) {\n        // trigger revalidate immediately\n        // to get the promise\n        revalidate();\n      }\n\n      if (CONCURRENT_PROMISES[key] && typeof CONCURRENT_PROMISES[key].then === 'function') {\n        // if it is a promise\n        throw CONCURRENT_PROMISES[key];\n      } // it's a value, return it directly (override)\n\n\n      latestData = CONCURRENT_PROMISES[key];\n    }\n\n    if (typeof latestData === 'undefined' && latestError) {\n      // in suspense mode, throw error if there's no content\n      throw latestError;\n    } // return the latest data / error from cache\n    // in case `key` has changed\n\n\n    return {\n      error: latestError,\n      data: latestData,\n      revalidate,\n      isValidating: stateRef.current.isValidating\n    };\n  } // define returned state\n  // can be memorized since the state is a ref\n\n\n  return useMemo(() => {\n    const state = {\n      revalidate\n    };\n\n    _Object$defineProperties(state, {\n      error: {\n        // `key` might be changed in the upcoming hook re-render,\n        // but the previous state will stay\n        // so we need to match the latest key and data (fallback to `initialData`)\n        get: function get() {\n          stateDependencies.current.error = true;\n          return keyRef.current === key ? stateRef.current.error : initialError;\n        }\n      },\n      data: {\n        get: function get() {\n          stateDependencies.current.data = true;\n          return keyRef.current === key ? stateRef.current.data : initialData;\n        }\n      },\n      isValidating: {\n        get: function get() {\n          stateDependencies.current.isValidating = true;\n          return stateRef.current.isValidating;\n        }\n      }\n    });\n\n    return state;\n  }, [revalidate]);\n}\n\nconst SWRConfig = SWRConfigContext.Provider;\nexport { trigger, mutate, SWRConfig };\nexport default useSWR;","map":{"version":3,"sources":["/home/andhi/code/torkhub/torkhub-app/node_modules/swr/esm/use-swr.js"],"names":["deepEqual","useCallback","useContext","useEffect","useLayoutEffect","useState","useRef","useMemo","defaultConfig","cacheGet","cacheSet","CACHE_REVALIDATORS","CONCURRENT_PROMISES","CONCURRENT_PROMISES_TS","FOCUS_REVALIDATORS","MUTATION_TS","hash","isDocumentVisible","isOnline","throttle","SWRConfigContext","IS_SERVER","useIsomorphicLayoutEffect","getErrorKey","key","getKeyArgs","args","err","String","trigger","_key","shouldRevalidate","updaters","currentData","currentError","i","length","broadcastState","data","error","mutate","_data","then","useSWR","fn","config","fnArgs","keyErr","fetcher","initialData","initialError","stateDependencies","isValidating","stateRef","rerender","dispatch","payload","shouldUpdateState","k","current","suspense","unmountedRef","keyRef","revalidate","revalidateOpts","dedupe","loading","shouldDeduping","startAt","newData","loadingTimeout","setTimeout","onLoadingSlow","dedupingInterval","onSuccess","undefined","newState","onError","shouldRetryOnError","retryCount","onErrorRetry","currentHookData","latestKeyedData","softRevalidate","window","onFocus","revalidateOnFocus","focusThrottleInterval","push","onUpdate","updatedData","updatedError","needUpdate","reconnect","revalidateOnReconnect","addEventListener","revalidators","index","indexOf","pop","removeEventListener","timer","tick","refreshWhenHidden","refreshWhenOffline","refreshInterval","clearTimeout","Error","latestData","latestError","state","get","SWRConfig","Provider"],"mappings":"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","sourcesContent":["import deepEqual from 'fast-deep-equal';\nimport { useCallback, useContext, useEffect, useLayoutEffect, useState, useRef, useMemo } from 'react';\nimport defaultConfig, { cacheGet, cacheSet, CACHE_REVALIDATORS, CONCURRENT_PROMISES, CONCURRENT_PROMISES_TS, FOCUS_REVALIDATORS, MUTATION_TS } from './config';\nimport hash from './libs/hash';\nimport isDocumentVisible from './libs/is-document-visible';\nimport isOnline from './libs/is-online';\nimport throttle from './libs/throttle';\nimport SWRConfigContext from './swr-config-context';\nconst IS_SERVER = typeof window === 'undefined';\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\n// TODO: introduce namepsace for the cache\nconst getErrorKey = key => (key ? 'err@' + key : '');\nconst getKeyArgs = key => {\n    let args = null;\n    if (typeof key === 'function') {\n        try {\n            key = key();\n        }\n        catch (err) {\n            // dependencies not ready\n            key = '';\n        }\n    }\n    if (Array.isArray(key)) {\n        // args array\n        args = key;\n        key = hash(key);\n    }\n    else {\n        // convert null to ''\n        key = String(key || '');\n    }\n    return [key, args];\n};\nconst trigger = (_key, shouldRevalidate = true) => {\n    const [key] = getKeyArgs(_key);\n    if (!key)\n        return;\n    const updaters = CACHE_REVALIDATORS[key];\n    if (key && updaters) {\n        const currentData = cacheGet(key);\n        const currentError = cacheGet(getErrorKey(key));\n        for (let i = 0; i < updaters.length; ++i) {\n            updaters[i](shouldRevalidate, currentData, currentError, true);\n        }\n    }\n};\nconst broadcastState = (key, data, error) => {\n    const updaters = CACHE_REVALIDATORS[key];\n    if (key && updaters) {\n        for (let i = 0; i < updaters.length; ++i) {\n            updaters[i](false, data, error);\n        }\n    }\n};\nconst mutate = async (_key, _data, shouldRevalidate) => {\n    const [key] = getKeyArgs(_key);\n    if (!key)\n        return;\n    // update timestamp\n    MUTATION_TS[key] = Date.now() - 1;\n    let data, error;\n    if (_data && typeof _data.then === 'function') {\n        // `_data` is a promise\n        try {\n            data = await _data;\n        }\n        catch (err) {\n            error = err;\n        }\n    }\n    else {\n        data = _data;\n        if (typeof shouldRevalidate === 'undefined') {\n            // if it's a sync mutation, we trigger the revalidation by default\n            // because in most cases it's a local mutation\n            shouldRevalidate = true;\n        }\n    }\n    if (typeof data !== 'undefined') {\n        // update cached data\n        cacheSet(key, data);\n    }\n    // update existing SWR Hooks' state\n    const updaters = CACHE_REVALIDATORS[key];\n    if (updaters) {\n        for (let i = 0; i < updaters.length; ++i) {\n            updaters[i](!!shouldRevalidate, data, error, true);\n        }\n    }\n};\nfunction useSWR(...args) {\n    let _key, fn, config = {};\n    if (args.length >= 1) {\n        _key = args[0];\n    }\n    if (args.length > 2) {\n        fn = args[1];\n        config = args[2];\n    }\n    else {\n        if (typeof args[1] === 'function') {\n            fn = args[1];\n        }\n        else if (typeof args[1] === 'object') {\n            config = args[1];\n        }\n    }\n    // we assume `key` as the identifier of the request\n    // `key` can change but `fn` shouldn't\n    // (because `revalidate` only depends on `key`)\n    const [key, fnArgs] = getKeyArgs(_key);\n    // `keyErr` is the cache key for error objects\n    const keyErr = getErrorKey(key);\n    config = Object.assign({}, defaultConfig, useContext(SWRConfigContext), config);\n    if (typeof fn === 'undefined') {\n        // use a global fetcher\n        fn = config.fetcher;\n    }\n    const initialData = cacheGet(key) || config.initialData;\n    const initialError = cacheGet(keyErr);\n    // if a state is accessed (data, error or isValidating),\n    // we add the state to dependencies so if the state is\n    // updated in the future, we can trigger a rerender\n    const stateDependencies = useRef({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    const stateRef = useRef({\n        data: initialData,\n        error: initialError,\n        isValidating: false\n    });\n    const rerender = useState(null)[1];\n    let dispatch = useCallback(payload => {\n        let shouldUpdateState = false;\n        for (let k in payload) {\n            stateRef.current[k] = payload[k];\n            if (stateDependencies.current[k]) {\n                shouldUpdateState = true;\n            }\n        }\n        if (shouldUpdateState || config.suspense) {\n            rerender({});\n        }\n    }, []);\n    // error ref inside revalidate (is last request errored?)\n    const unmountedRef = useRef(false);\n    const keyRef = useRef(key);\n    // start a revalidation\n    const revalidate = useCallback(async (revalidateOpts = {}) => {\n        if (!key || !fn)\n            return false;\n        if (unmountedRef.current)\n            return false;\n        revalidateOpts = Object.assign({ dedupe: false }, revalidateOpts);\n        let loading = true;\n        let shouldDeduping = typeof CONCURRENT_PROMISES[key] !== 'undefined' && revalidateOpts.dedupe;\n        // start fetching\n        try {\n            dispatch({\n                isValidating: true\n            });\n            let newData;\n            let startAt;\n            if (shouldDeduping) {\n                // there's already an ongoing request,\n                // this one needs to be deduplicated.\n                startAt = CONCURRENT_PROMISES_TS[key];\n                newData = await CONCURRENT_PROMISES[key];\n            }\n            else {\n                // if not deduping the request (hard revalidate) but\n                // there're other ongoing request(s) at the same time,\n                // we need to ignore the other result(s) to avoid\n                // possible race conditions:\n                // req1------------------>res1\n                //      req2-------->res2\n                // in that case, the second response should not be overridden\n                // by the first one.\n                if (CONCURRENT_PROMISES[key]) {\n                    // we can mark it as a mutation to ignore\n                    // all requests which are fired before this one\n                    MUTATION_TS[key] = Date.now() - 1;\n                }\n                // if no cache being rendered currently (it shows a blank page),\n                // we trigger the loading slow event.\n                if (config.loadingTimeout && !cacheGet(key)) {\n                    setTimeout(() => {\n                        if (loading)\n                            config.onLoadingSlow(key, config);\n                    }, config.loadingTimeout);\n                }\n                if (fnArgs !== null) {\n                    CONCURRENT_PROMISES[key] = fn(...fnArgs);\n                }\n                else {\n                    CONCURRENT_PROMISES[key] = fn(key);\n                }\n                CONCURRENT_PROMISES_TS[key] = startAt = Date.now();\n                setTimeout(() => {\n                    delete CONCURRENT_PROMISES[key];\n                    delete CONCURRENT_PROMISES_TS[key];\n                }, config.dedupingInterval);\n                newData = await CONCURRENT_PROMISES[key];\n                // trigger the success event,\n                // only do this for the original request.\n                config.onSuccess(newData, key, config);\n            }\n            // if the revalidation happened earlier than the local mutation,\n            // we have to ignore the result because it could override.\n            // meanwhile, a new revalidation should be triggered by the mutation.\n            if (MUTATION_TS[key] && startAt <= MUTATION_TS[key]) {\n                dispatch({ isValidating: false });\n                return false;\n            }\n            cacheSet(key, newData);\n            cacheSet(keyErr, undefined);\n            keyRef.current = key;\n            // new state for the reducer\n            const newState = {\n                isValidating: false\n            };\n            if (typeof stateRef.current.error !== 'undefined') {\n                // we don't have an error\n                newState.error = undefined;\n            }\n            if (deepEqual(stateRef.current.data, newData)) {\n                // deep compare to avoid extra re-render\n                // do nothing\n            }\n            else {\n                // data changed\n                newState.data = newData;\n            }\n            // merge the new state\n            dispatch(newState);\n            if (!shouldDeduping) {\n                // also update other hooks\n                broadcastState(key, newData, undefined);\n            }\n        }\n        catch (err) {\n            delete CONCURRENT_PROMISES[key];\n            delete CONCURRENT_PROMISES_TS[key];\n            cacheSet(keyErr, err);\n            keyRef.current = key;\n            // get a new error\n            // don't use deep equal for errors\n            if (stateRef.current.error !== err) {\n                // we keep the stale data\n                dispatch({\n                    isValidating: false,\n                    error: err\n                });\n                if (!shouldDeduping) {\n                    // also broadcast to update other hooks\n                    broadcastState(key, undefined, err);\n                }\n            }\n            // events and retry\n            config.onError(err, key, config);\n            if (config.shouldRetryOnError) {\n                // when retrying, we always enable deduping\n                const retryCount = (revalidateOpts.retryCount || 0) + 1;\n                config.onErrorRetry(err, key, config, revalidate, Object.assign({ dedupe: true }, revalidateOpts, { retryCount }));\n            }\n        }\n        loading = false;\n        return true;\n    }, [key]);\n    // mounted (client side rendering)\n    useIsomorphicLayoutEffect(() => {\n        if (!key)\n            return undefined;\n        // after `key` updates, we need to mark it as mounted\n        unmountedRef.current = false;\n        // after the component is mounted (hydrated),\n        // we need to update the data from the cache\n        // and trigger a revalidation\n        const currentHookData = stateRef.current.data;\n        const latestKeyedData = cacheGet(key) || config.initialData;\n        // update the state if the key changed or cache updated\n        if (keyRef.current !== key ||\n            !deepEqual(currentHookData, latestKeyedData)) {\n            dispatch({ data: latestKeyedData });\n            keyRef.current = key;\n        }\n        // revalidate with deduping\n        const softRevalidate = () => revalidate({ dedupe: true });\n        // trigger a revalidation\n        if (!config.initialData) {\n            if (typeof latestKeyedData !== 'undefined' &&\n                !IS_SERVER &&\n                window['requestIdleCallback']) {\n                // delay revalidate if there's cache\n                // to not block the rendering\n                window['requestIdleCallback'](softRevalidate);\n            }\n            else {\n                softRevalidate();\n            }\n        }\n        // whenever the window gets focused, revalidate\n        let onFocus;\n        if (config.revalidateOnFocus) {\n            // throttle: avoid being called twice from both listeners\n            // and tabs being switched quickly\n            onFocus = throttle(softRevalidate, config.focusThrottleInterval);\n            if (!FOCUS_REVALIDATORS[key]) {\n                FOCUS_REVALIDATORS[key] = [onFocus];\n            }\n            else {\n                FOCUS_REVALIDATORS[key].push(onFocus);\n            }\n        }\n        // register global cache update listener\n        const onUpdate = (shouldRevalidate = true, updatedData, updatedError, dedupe = true) => {\n            // update hook state\n            const newState = {};\n            let needUpdate = false;\n            if (typeof updatedData !== 'undefined' &&\n                !deepEqual(stateRef.current.data, updatedData)) {\n                newState.data = updatedData;\n                needUpdate = true;\n            }\n            // always update error\n            // because it can be `undefined`\n            if (stateRef.current.error !== updatedError) {\n                newState.error = updatedError;\n                needUpdate = true;\n            }\n            if (needUpdate) {\n                dispatch(newState);\n            }\n            keyRef.current = key;\n            if (shouldRevalidate) {\n                if (dedupe) {\n                    return softRevalidate();\n                }\n                else {\n                    return revalidate();\n                }\n            }\n            return false;\n        };\n        // add updater to listeners\n        if (!CACHE_REVALIDATORS[key]) {\n            CACHE_REVALIDATORS[key] = [onUpdate];\n        }\n        else {\n            CACHE_REVALIDATORS[key].push(onUpdate);\n        }\n        // set up reconnecting when the browser regains network connection\n        let reconnect = null;\n        if (config.revalidateOnReconnect) {\n            reconnect = addEventListener('online', softRevalidate);\n        }\n        return () => {\n            // cleanup\n            dispatch = () => null;\n            // mark it as unmounted\n            unmountedRef.current = true;\n            if (onFocus && FOCUS_REVALIDATORS[key]) {\n                const revalidators = FOCUS_REVALIDATORS[key];\n                const index = revalidators.indexOf(onFocus);\n                if (index >= 0) {\n                    // 10x faster than splice\n                    // https://jsperf.com/array-remove-by-index\n                    revalidators[index] = revalidators[revalidators.length - 1];\n                    revalidators.pop();\n                }\n            }\n            if (CACHE_REVALIDATORS[key]) {\n                const revalidators = CACHE_REVALIDATORS[key];\n                const index = revalidators.indexOf(onUpdate);\n                if (index >= 0) {\n                    revalidators[index] = revalidators[revalidators.length - 1];\n                    revalidators.pop();\n                }\n            }\n            if (reconnect !== null) {\n                removeEventListener('online', reconnect);\n            }\n        };\n    }, [key, revalidate]);\n    // set up polling\n    useIsomorphicLayoutEffect(() => {\n        let timer = null;\n        const tick = async () => {\n            if (!stateRef.current.error &&\n                (config.refreshWhenHidden || isDocumentVisible()) &&\n                (!config.refreshWhenOffline && isOnline())) {\n                // only revalidate when the page is visible\n                // if API request errored, we stop polling in this round\n                // and let the error retry function handle it\n                await revalidate({ dedupe: true });\n            }\n            if (config.refreshInterval) {\n                timer = setTimeout(tick, config.refreshInterval);\n            }\n        };\n        if (config.refreshInterval) {\n            timer = setTimeout(tick, config.refreshInterval);\n        }\n        return () => {\n            if (timer)\n                clearTimeout(timer);\n        };\n    }, [\n        config.refreshInterval,\n        config.refreshWhenHidden,\n        config.refreshWhenOffline,\n        revalidate\n    ]);\n    // suspense\n    if (config.suspense) {\n        if (IS_SERVER)\n            throw new Error('Suspense on server side is not yet supported!');\n        // in suspense mode, we can't return empty state\n        // (it should be suspended)\n        // try to get data and error from cache\n        let latestData = cacheGet(key);\n        let latestError = cacheGet(keyErr);\n        if (typeof latestData === 'undefined' &&\n            typeof latestError === 'undefined') {\n            // need to start the request if it hasn't\n            if (!CONCURRENT_PROMISES[key]) {\n                // trigger revalidate immediately\n                // to get the promise\n                revalidate();\n            }\n            if (CONCURRENT_PROMISES[key] &&\n                typeof CONCURRENT_PROMISES[key].then === 'function') {\n                // if it is a promise\n                throw CONCURRENT_PROMISES[key];\n            }\n            // it's a value, return it directly (override)\n            latestData = CONCURRENT_PROMISES[key];\n        }\n        if (typeof latestData === 'undefined' && latestError) {\n            // in suspense mode, throw error if there's no content\n            throw latestError;\n        }\n        // return the latest data / error from cache\n        // in case `key` has changed\n        return {\n            error: latestError,\n            data: latestData,\n            revalidate,\n            isValidating: stateRef.current.isValidating\n        };\n    }\n    // define returned state\n    // can be memorized since the state is a ref\n    return useMemo(() => {\n        const state = { revalidate };\n        Object.defineProperties(state, {\n            error: {\n                // `key` might be changed in the upcoming hook re-render,\n                // but the previous state will stay\n                // so we need to match the latest key and data (fallback to `initialData`)\n                get: function () {\n                    stateDependencies.current.error = true;\n                    return keyRef.current === key ? stateRef.current.error : initialError;\n                }\n            },\n            data: {\n                get: function () {\n                    stateDependencies.current.data = true;\n                    return keyRef.current === key ? stateRef.current.data : initialData;\n                }\n            },\n            isValidating: {\n                get: function () {\n                    stateDependencies.current.isValidating = true;\n                    return stateRef.current.isValidating;\n                }\n            }\n        });\n        return state;\n    }, [revalidate]);\n}\nconst SWRConfig = SWRConfigContext.Provider;\nexport { trigger, mutate, SWRConfig };\nexport default useSWR;\n"]},"metadata":{},"sourceType":"module"}