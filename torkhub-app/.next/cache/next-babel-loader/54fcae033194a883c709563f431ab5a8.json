{"ast":null,"code":"import _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _Date$now from \"@babel/runtime-corejs2/core-js/date/now\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport deepEqual from 'fast-deep-equal';\nimport { useCallback, useContext, useEffect, useLayoutEffect, useState, useRef, useMemo } from 'react';\nimport defaultConfig, { cacheGet, cacheSet, CACHE_REVALIDATORS, CONCURRENT_PROMISES, CONCURRENT_PROMISES_TS, FOCUS_REVALIDATORS, MUTATION_TS } from './config';\nimport hash from './libs/hash';\nimport isDocumentVisible from './libs/is-document-visible';\nimport isOnline from './libs/is-online';\nimport throttle from './libs/throttle';\nimport SWRConfigContext from './swr-config-context';\nconst IS_SERVER = false; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\n\nconst useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect; // TODO: introduce namepsace for the cache\n\nconst getErrorKey = key => key ? 'err@' + key : '';\n\nconst getKeyArgs = key => {\n  let args = null;\n\n  if (typeof key === 'function') {\n    try {\n      key = key();\n    } catch (err) {\n      // dependencies not ready\n      key = '';\n    }\n  }\n\n  if (_Array$isArray(key)) {\n    // args array\n    args = key;\n    key = hash(key);\n  } else {\n    // convert null to ''\n    key = String(key || '');\n  }\n\n  return [key, args];\n};\n\nconst trigger = (_key, shouldRevalidate = true) => {\n  const _getKeyArgs = getKeyArgs(_key),\n        _getKeyArgs2 = _slicedToArray(_getKeyArgs, 1),\n        key = _getKeyArgs2[0];\n\n  if (!key) return;\n  const updaters = CACHE_REVALIDATORS[key];\n\n  if (key && updaters) {\n    const currentData = cacheGet(key);\n    const currentError = cacheGet(getErrorKey(key));\n\n    for (let i = 0; i < updaters.length; ++i) {\n      updaters[i](shouldRevalidate, currentData, currentError, true);\n    }\n  }\n};\n\nconst broadcastState = (key, data, error) => {\n  const updaters = CACHE_REVALIDATORS[key];\n\n  if (key && updaters) {\n    for (let i = 0; i < updaters.length; ++i) {\n      updaters[i](false, data, error);\n    }\n  }\n};\n\nconst mutate = (_key, _data, shouldRevalidate) => {\n  var _getKeyArgs3, _getKeyArgs4, key, data, error, updaters, i;\n\n  return _regeneratorRuntime.async(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        _getKeyArgs3 = getKeyArgs(_key), _getKeyArgs4 = _slicedToArray(_getKeyArgs3, 1), key = _getKeyArgs4[0];\n\n        if (key) {\n          _context.next = 3;\n          break;\n        }\n\n        return _context.abrupt(\"return\");\n\n      case 3:\n        // update timestamp\n        MUTATION_TS[key] = _Date$now() - 1;\n\n        if (!(_data && typeof _data.then === 'function')) {\n          _context.next = 16;\n          break;\n        }\n\n        _context.prev = 5;\n        _context.next = 8;\n        return _regeneratorRuntime.awrap(_data);\n\n      case 8:\n        data = _context.sent;\n        _context.next = 14;\n        break;\n\n      case 11:\n        _context.prev = 11;\n        _context.t0 = _context[\"catch\"](5);\n        error = _context.t0;\n\n      case 14:\n        _context.next = 18;\n        break;\n\n      case 16:\n        data = _data;\n\n        if (typeof shouldRevalidate === 'undefined') {\n          // if it's a sync mutation, we trigger the revalidation by default\n          // because in most cases it's a local mutation\n          shouldRevalidate = true;\n        }\n\n      case 18:\n        if (typeof data !== 'undefined') {\n          // update cached data\n          cacheSet(key, data);\n        } // update existing SWR Hooks' state\n\n\n        updaters = CACHE_REVALIDATORS[key];\n\n        if (updaters) {\n          for (i = 0; i < updaters.length; ++i) {\n            updaters[i](!!shouldRevalidate, data, error, true);\n          }\n        }\n\n      case 21:\n      case \"end\":\n        return _context.stop();\n    }\n  }, null, null, [[5, 11]], _Promise);\n};\n\nfunction useSWR(...args) {\n  let _key,\n      fn,\n      config = {};\n\n  if (args.length >= 1) {\n    _key = args[0];\n  }\n\n  if (args.length > 2) {\n    fn = args[1];\n    config = args[2];\n  } else {\n    if (typeof args[1] === 'function') {\n      fn = args[1];\n    } else if (typeof args[1] === 'object') {\n      config = args[1];\n    }\n  } // we assume `key` as the identifier of the request\n  // `key` can change but `fn` shouldn't\n  // (because `revalidate` only depends on `key`)\n\n\n  const _getKeyArgs5 = getKeyArgs(_key),\n        _getKeyArgs6 = _slicedToArray(_getKeyArgs5, 2),\n        key = _getKeyArgs6[0],\n        fnArgs = _getKeyArgs6[1]; // `keyErr` is the cache key for error objects\n\n\n  const keyErr = getErrorKey(key);\n  config = _Object$assign({}, defaultConfig, useContext(SWRConfigContext), config);\n\n  if (typeof fn === 'undefined') {\n    // use a global fetcher\n    fn = config.fetcher;\n  }\n\n  const initialData = cacheGet(key) || config.initialData;\n  const initialError = cacheGet(keyErr); // if a state is accessed (data, error or isValidating),\n  // we add the state to dependencies so if the state is\n  // updated in the future, we can trigger a rerender\n\n  const stateDependencies = useRef({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  const stateRef = useRef({\n    data: initialData,\n    error: initialError,\n    isValidating: false\n  });\n  const rerender = useState(null)[1];\n  let dispatch = useCallback(payload => {\n    let shouldUpdateState = false;\n\n    for (let k in payload) {\n      stateRef.current[k] = payload[k];\n\n      if (stateDependencies.current[k]) {\n        shouldUpdateState = true;\n      }\n    }\n\n    if (shouldUpdateState || config.suspense) {\n      rerender({});\n    }\n  }, []); // error ref inside revalidate (is last request errored?)\n\n  const unmountedRef = useRef(false);\n  const keyRef = useRef(key); // start a revalidation\n\n  const revalidate = useCallback((revalidateOpts = {}) => {\n    var loading, shouldDeduping, newData, startAt, newState, retryCount;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(!key || !fn)) {\n            _context2.next = 2;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", false);\n\n        case 2:\n          if (!unmountedRef.current) {\n            _context2.next = 4;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", false);\n\n        case 4:\n          revalidateOpts = _Object$assign({\n            dedupe: false\n          }, revalidateOpts);\n          loading = true;\n          shouldDeduping = typeof CONCURRENT_PROMISES[key] !== 'undefined' && revalidateOpts.dedupe; // start fetching\n\n          _context2.prev = 7;\n          dispatch({\n            isValidating: true\n          });\n\n          if (!shouldDeduping) {\n            _context2.next = 16;\n            break;\n          }\n\n          // there's already an ongoing request,\n          // this one needs to be deduplicated.\n          startAt = CONCURRENT_PROMISES_TS[key];\n          _context2.next = 13;\n          return _regeneratorRuntime.awrap(CONCURRENT_PROMISES[key]);\n\n        case 13:\n          newData = _context2.sent;\n          _context2.next = 25;\n          break;\n\n        case 16:\n          // if not deduping the request (hard revalidate) but\n          // there're other ongoing request(s) at the same time,\n          // we need to ignore the other result(s) to avoid\n          // possible race conditions:\n          // req1------------------>res1\n          //      req2-------->res2\n          // in that case, the second response should not be overridden\n          // by the first one.\n          if (CONCURRENT_PROMISES[key]) {\n            // we can mark it as a mutation to ignore\n            // all requests which are fired before this one\n            MUTATION_TS[key] = _Date$now() - 1;\n          } // if no cache being rendered currently (it shows a blank page),\n          // we trigger the loading slow event.\n\n\n          if (config.loadingTimeout && !cacheGet(key)) {\n            setTimeout(() => {\n              if (loading) config.onLoadingSlow(key, config);\n            }, config.loadingTimeout);\n          }\n\n          if (fnArgs !== null) {\n            CONCURRENT_PROMISES[key] = fn(...fnArgs);\n          } else {\n            CONCURRENT_PROMISES[key] = fn(key);\n          }\n\n          CONCURRENT_PROMISES_TS[key] = startAt = _Date$now();\n          setTimeout(() => {\n            delete CONCURRENT_PROMISES[key];\n            delete CONCURRENT_PROMISES_TS[key];\n          }, config.dedupingInterval);\n          _context2.next = 23;\n          return _regeneratorRuntime.awrap(CONCURRENT_PROMISES[key]);\n\n        case 23:\n          newData = _context2.sent;\n          // trigger the success event,\n          // only do this for the original request.\n          config.onSuccess(newData, key, config);\n\n        case 25:\n          if (!(MUTATION_TS[key] && startAt <= MUTATION_TS[key])) {\n            _context2.next = 28;\n            break;\n          }\n\n          dispatch({\n            isValidating: false\n          });\n          return _context2.abrupt(\"return\", false);\n\n        case 28:\n          cacheSet(key, newData);\n          cacheSet(keyErr, undefined);\n          keyRef.current = key; // new state for the reducer\n\n          newState = {\n            isValidating: false\n          };\n\n          if (typeof stateRef.current.error !== 'undefined') {\n            // we don't have an error\n            newState.error = undefined;\n          }\n\n          if (deepEqual(stateRef.current.data, newData)) {// deep compare to avoid extra re-render\n            // do nothing\n          } else {\n            // data changed\n            newState.data = newData;\n          } // merge the new state\n\n\n          dispatch(newState);\n\n          if (!shouldDeduping) {\n            // also update other hooks\n            broadcastState(key, newData, undefined);\n          }\n\n          _context2.next = 47;\n          break;\n\n        case 38:\n          _context2.prev = 38;\n          _context2.t0 = _context2[\"catch\"](7);\n          delete CONCURRENT_PROMISES[key];\n          delete CONCURRENT_PROMISES_TS[key];\n          cacheSet(keyErr, _context2.t0);\n          keyRef.current = key; // get a new error\n          // don't use deep equal for errors\n\n          if (stateRef.current.error !== _context2.t0) {\n            // we keep the stale data\n            dispatch({\n              isValidating: false,\n              error: _context2.t0\n            });\n\n            if (!shouldDeduping) {\n              // also broadcast to update other hooks\n              broadcastState(key, undefined, _context2.t0);\n            }\n          } // events and retry\n\n\n          config.onError(_context2.t0, key, config);\n\n          if (config.shouldRetryOnError) {\n            // when retrying, we always enable deduping\n            retryCount = (revalidateOpts.retryCount || 0) + 1;\n            config.onErrorRetry(_context2.t0, key, config, revalidate, _Object$assign({\n              dedupe: true\n            }, revalidateOpts, {\n              retryCount\n            }));\n          }\n\n        case 47:\n          loading = false;\n          return _context2.abrupt(\"return\", true);\n\n        case 49:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, null, null, [[7, 38]], _Promise);\n  }, [key]); // mounted (client side rendering)\n\n  useIsomorphicLayoutEffect(() => {\n    if (!key) return undefined; // after `key` updates, we need to mark it as mounted\n\n    unmountedRef.current = false; // after the component is mounted (hydrated),\n    // we need to update the data from the cache\n    // and trigger a revalidation\n\n    const currentHookData = stateRef.current.data;\n    const latestKeyedData = cacheGet(key) || config.initialData; // update the state if the key changed or cache updated\n\n    if (keyRef.current !== key || !deepEqual(currentHookData, latestKeyedData)) {\n      dispatch({\n        data: latestKeyedData\n      });\n      keyRef.current = key;\n    } // revalidate with deduping\n\n\n    const softRevalidate = () => revalidate({\n      dedupe: true\n    }); // trigger a revalidation\n\n\n    if (!config.initialData) {\n      if (typeof latestKeyedData !== 'undefined' && !IS_SERVER && window['requestIdleCallback']) {\n        // delay revalidate if there's cache\n        // to not block the rendering\n        window['requestIdleCallback'](softRevalidate);\n      } else {\n        softRevalidate();\n      }\n    } // whenever the window gets focused, revalidate\n\n\n    let onFocus;\n\n    if (config.revalidateOnFocus) {\n      // throttle: avoid being called twice from both listeners\n      // and tabs being switched quickly\n      onFocus = throttle(softRevalidate, config.focusThrottleInterval);\n\n      if (!FOCUS_REVALIDATORS[key]) {\n        FOCUS_REVALIDATORS[key] = [onFocus];\n      } else {\n        FOCUS_REVALIDATORS[key].push(onFocus);\n      }\n    } // register global cache update listener\n\n\n    const onUpdate = (shouldRevalidate = true, updatedData, updatedError, dedupe = true) => {\n      // update hook state\n      const newState = {};\n      let needUpdate = false;\n\n      if (typeof updatedData !== 'undefined' && !deepEqual(stateRef.current.data, updatedData)) {\n        newState.data = updatedData;\n        needUpdate = true;\n      } // always update error\n      // because it can be `undefined`\n\n\n      if (stateRef.current.error !== updatedError) {\n        newState.error = updatedError;\n        needUpdate = true;\n      }\n\n      if (needUpdate) {\n        dispatch(newState);\n      }\n\n      keyRef.current = key;\n\n      if (shouldRevalidate) {\n        if (dedupe) {\n          return softRevalidate();\n        } else {\n          return revalidate();\n        }\n      }\n\n      return false;\n    }; // add updater to listeners\n\n\n    if (!CACHE_REVALIDATORS[key]) {\n      CACHE_REVALIDATORS[key] = [onUpdate];\n    } else {\n      CACHE_REVALIDATORS[key].push(onUpdate);\n    } // set up reconnecting when the browser regains network connection\n\n\n    let reconnect = null;\n\n    if (config.revalidateOnReconnect) {\n      reconnect = addEventListener('online', softRevalidate);\n    }\n\n    return () => {\n      // cleanup\n      dispatch = () => null; // mark it as unmounted\n\n\n      unmountedRef.current = true;\n\n      if (onFocus && FOCUS_REVALIDATORS[key]) {\n        const revalidators = FOCUS_REVALIDATORS[key];\n        const index = revalidators.indexOf(onFocus);\n\n        if (index >= 0) {\n          // 10x faster than splice\n          // https://jsperf.com/array-remove-by-index\n          revalidators[index] = revalidators[revalidators.length - 1];\n          revalidators.pop();\n        }\n      }\n\n      if (CACHE_REVALIDATORS[key]) {\n        const revalidators = CACHE_REVALIDATORS[key];\n        const index = revalidators.indexOf(onUpdate);\n\n        if (index >= 0) {\n          revalidators[index] = revalidators[revalidators.length - 1];\n          revalidators.pop();\n        }\n      }\n\n      if (reconnect !== null) {\n        removeEventListener('online', reconnect);\n      }\n    };\n  }, [key, revalidate]); // set up polling\n\n  useIsomorphicLayoutEffect(() => {\n    let timer = null;\n\n    const tick = () => {\n      return _regeneratorRuntime.async(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(!stateRef.current.error && (config.refreshWhenHidden || isDocumentVisible()) && !config.refreshWhenOffline && isOnline())) {\n              _context3.next = 3;\n              break;\n            }\n\n            _context3.next = 3;\n            return _regeneratorRuntime.awrap(revalidate({\n              dedupe: true\n            }));\n\n          case 3:\n            if (config.refreshInterval) {\n              timer = setTimeout(tick, config.refreshInterval);\n            }\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, null, null, null, _Promise);\n    };\n\n    if (config.refreshInterval) {\n      timer = setTimeout(tick, config.refreshInterval);\n    }\n\n    return () => {\n      if (timer) clearTimeout(timer);\n    };\n  }, [config.refreshInterval, config.refreshWhenHidden, config.refreshWhenOffline, revalidate]); // suspense\n\n  if (config.suspense) {\n    if (IS_SERVER) throw new Error('Suspense on server side is not yet supported!'); // in suspense mode, we can't return empty state\n    // (it should be suspended)\n    // try to get data and error from cache\n\n    let latestData = cacheGet(key);\n    let latestError = cacheGet(keyErr);\n\n    if (typeof latestData === 'undefined' && typeof latestError === 'undefined') {\n      // need to start the request if it hasn't\n      if (!CONCURRENT_PROMISES[key]) {\n        // trigger revalidate immediately\n        // to get the promise\n        revalidate();\n      }\n\n      if (CONCURRENT_PROMISES[key] && typeof CONCURRENT_PROMISES[key].then === 'function') {\n        // if it is a promise\n        throw CONCURRENT_PROMISES[key];\n      } // it's a value, return it directly (override)\n\n\n      latestData = CONCURRENT_PROMISES[key];\n    }\n\n    if (typeof latestData === 'undefined' && latestError) {\n      // in suspense mode, throw error if there's no content\n      throw latestError;\n    } // return the latest data / error from cache\n    // in case `key` has changed\n\n\n    return {\n      error: latestError,\n      data: latestData,\n      revalidate,\n      isValidating: stateRef.current.isValidating\n    };\n  } // define returned state\n  // can be memorized since the state is a ref\n\n\n  return useMemo(() => {\n    const state = {\n      revalidate\n    };\n\n    _Object$defineProperties(state, {\n      error: {\n        // `key` might be changed in the upcoming hook re-render,\n        // but the previous state will stay\n        // so we need to match the latest key and data (fallback to `initialData`)\n        get: function get() {\n          stateDependencies.current.error = true;\n          return keyRef.current === key ? stateRef.current.error : initialError;\n        }\n      },\n      data: {\n        get: function get() {\n          stateDependencies.current.data = true;\n          return keyRef.current === key ? stateRef.current.data : initialData;\n        }\n      },\n      isValidating: {\n        get: function get() {\n          stateDependencies.current.isValidating = true;\n          return stateRef.current.isValidating;\n        }\n      }\n    });\n\n    return state;\n  }, [revalidate]);\n}\n\nconst SWRConfig = SWRConfigContext.Provider;\nexport { trigger, mutate, SWRConfig };\nexport default useSWR;","map":null,"metadata":{},"sourceType":"module"}